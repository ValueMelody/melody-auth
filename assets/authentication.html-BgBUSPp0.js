import{_ as a,c as l,a as i,b as t,d as r,e,w as o,r as g,o as d}from"./app-DYNaD-s_.js";const h={};function p(u,n){const s=g("RouteLink");return d(),l("div",null,[n[10]||(n[10]=i('<h1 id="身份认证" tabindex="-1"><a class="header-anchor" href="#身份认证"><span>身份认证</span></a></h1><p>Melody Auth 提供多种认证方式以满足不同的集成需求：</p><ul><li><strong>PKCE 流程</strong>（Proof Key for Code Exchange）——前端应用的 <strong>默认且推荐</strong> OAuth 2.0 授权码流程</li><li><strong>嵌入式认证流程</strong> —— 通过直接 API 集成实现自定义认证体验</li></ul><h2 id="什么是-pkce" tabindex="-1"><a class="header-anchor" href="#什么是-pkce"><span>什么是 PKCE？</span></a></h2><p><strong>PKCE</strong>（Proof Key for Code Exchange）是 OAuth 2.0 授权码流程的安全扩展，旨在增强公共客户端（如单页应用 SPA 和移动应用）的安全性，这些客户端无法安全地存储 client secret。</p><p>PKCE 引入了一个动态生成的一次性密钥，称为 <strong>code verifier</strong>，用于保护授权码交换过程。这消除了公共客户端存储 client secret 的需求，同时保持了安全性。</p><h2 id="安全优势" tabindex="-1"><a class="header-anchor" href="#安全优势"><span>安全优势</span></a></h2><ul><li><strong>防止授权码拦截</strong>：即使攻击者拦截了授权码，没有原始的 code verifier 也无法换取 token</li><li><strong>消除 Client Secret 要求</strong>：公共客户端无需存储敏感的 client secret 也能安全认证</li><li><strong>缓解 CSRF 攻击</strong>：将授权请求绑定到发起请求的特定客户端</li><li><strong>防止代码注入攻击</strong>：确保只有合法的客户端才能完成流程</li></ul><h2 id="pkce-下的认证操作工作方式" tabindex="-1"><a class="header-anchor" href="#pkce-下的认证操作工作方式"><span>PKCE 下的认证操作工作方式</span></a></h2><p>所有认证操作都遵循相同的 PKCE 流程模式，只是在认证步骤上有所不同：</p><h3 id="标准-pkce-流程步骤" tabindex="-1"><a class="header-anchor" href="#标准-pkce-流程步骤"><span>标准 PKCE 流程步骤</span></a></h3><ol><li><strong>客户端生成 code verifier 和 challenge</strong></li><li><strong>用户被重定向到 Melody Auth 并携带 code challenge</strong></li><li><strong>用户执行认证操作</strong>（根据操作类型不同而不同）</li><li><strong>授权码返回给客户端</strong></li><li><strong>客户端使用 code + verifier 换取 token</strong></li></ol><h2 id="通过-pkce-的认证操作" tabindex="-1"><a class="header-anchor" href="#通过-pkce-的认证操作"><span>通过 PKCE 的认证操作</span></a></h2><p>Melody Auth 中的所有用户认证操作都可以通过 PKCE 流程完成，包括：</p><ul><li><strong>登录 (Sign-In)</strong> —— 标准邮箱/密码认证</li><li><strong>免密码登录 (Passwordless Sign-In)</strong> —— 基于邮箱的免密码认证</li><li><strong>注册 (Sign-Up)</strong> —— 新用户注册与账户创建</li><li><strong>登出 (Sign-Out)</strong> —— 会话终止和 token 撤销</li><li><strong>邮箱验证 (Email Verification)</strong> —— 确认用户邮箱地址</li><li><strong>密码重置 (Password Reset)</strong> —— 安全的密码恢复流程</li><li><strong>多因素认证 (MFA)</strong> —— 邮箱 MFA、短信 MFA、OTP MFA、Passkey 认证，以及 MFA 管理</li><li><strong>基于策略的认证 (Policy-Based Authentication)</strong> —— 自定义策略、条件访问和增强认证</li></ul><p>以上所有操作都使用相同的安全 PKCE 授权码流程，确保所有认证场景中的一致安全性。</p><h2 id="认证方式对比" tabindex="-1"><a class="header-anchor" href="#认证方式对比"><span>认证方式对比</span></a></h2><h3 id="pkce-流程-推荐" tabindex="-1"><a class="header-anchor" href="#pkce-流程-推荐"><span>PKCE 流程（推荐）</span></a></h3><ul><li><strong>适用场景</strong>：带有增强安全性的标准 OAuth 2.0 流程</li><li><strong>最适合</strong>：SPAs、移动应用和 Web 应用</li><li><strong>安全性</strong>：通过 code challenge/verifier 提供最高安全性</li><li><strong>集成方式</strong>：使用提供的 SDK 简单集成</li><li><strong>用户体验</strong>：重定向到托管的认证页面</li></ul><h3 id="嵌入式认证流程" tabindex="-1"><a class="header-anchor" href="#嵌入式认证流程"><span>嵌入式认证流程</span></a></h3><ul><li><strong>适用场景</strong>：应用内自定义认证 UI</li><li><strong>最适合</strong>：需要完全 UI 控制的应用</li><li><strong>安全性</strong>：通过直接 API 调用并正确处理 token</li><li><strong>集成方式</strong>：更复杂，需要自定义实现</li><li><strong>用户体验</strong>：无跳转，体验无缝</li></ul><h2 id="sdk-集成" tabindex="-1"><a class="header-anchor" href="#sdk-集成"><span>SDK 集成</span></a></h2><h3 id="pkce-流程-sdk" tabindex="-1"><a class="header-anchor" href="#pkce-流程-sdk"><span>PKCE 流程 SDK</span></a></h3>',23)),t("ul",null,[t("li",null,[r(s,{to:"/zh/zh/react-sdk.html"},{default:o(()=>n[0]||(n[0]=[e("React SDK 文档",-1)])),_:1,__:[0]}),n[1]||(n[1]=e(" —— React hooks 和组件",-1))]),t("li",null,[r(s,{to:"/zh/zh/vue-sdk.html"},{default:o(()=>n[2]||(n[2]=[e("Vue SDK 文档",-1)])),_:1,__:[2]}),n[3]||(n[3]=e(" —— Vue 3 composables 和插件",-1))]),t("li",null,[r(s,{to:"/zh/zh/angular-sdk.html"},{default:o(()=>n[4]||(n[4]=[e("Angular SDK 文档",-1)])),_:1,__:[4]}),n[5]||(n[5]=e(" —— Angular services 和 guards",-1))]),t("li",null,[r(s,{to:"/zh/zh/web-sdk.html"},{default:o(()=>n[6]||(n[6]=[e("Web SDK 文档",-1)])),_:1,__:[6]}),n[7]||(n[7]=e(" —— 原生 JavaScript 实现",-1))])]),n[11]||(n[11]=t("h3",{id:"嵌入式认证",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#嵌入式认证"},[t("span",null,"嵌入式认证")])],-1)),t("ul",null,[t("li",null,[r(s,{to:"/zh/zh/embedded-auth-api.html"},{default:o(()=>n[8]||(n[8]=[e("嵌入式认证 API 文档",-1)])),_:1,__:[8]}),n[9]||(n[9]=e(" —— 直接 API 集成指南",-1))])])])}const f=a(h,[["render",p]]),m=JSON.parse('{"path":"/zh/authentication.html","title":"身份认证","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1755304846000,"contributors":[{"name":"Baozier","username":"Baozier","email":"byn9826@gmail.com","commits":1,"url":"https://github.com/Baozier"}],"changelog":[{"hash":"5396c9586a61f59593ebaea2b6848496a7027f19","time":1755304846000,"email":"byn9826@gmail.com","author":"Baozier","message":"Add docs for main features (#428)"}]},"filePathRelative":"zh/authentication.md"}');export{f as comp,m as data};
