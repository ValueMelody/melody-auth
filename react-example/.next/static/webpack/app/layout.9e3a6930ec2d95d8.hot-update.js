"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/../web-sdk/dist/flows/loginRedirect.js":
/*!**********************************************!*\
  !*** ../web-sdk/dist/flows/loginRedirect.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.loginRedirect = void 0;\nvar definitions_1 = __webpack_require__(/*! ../definitions */ \"(app-pages-browser)/../web-sdk/dist/definitions.js\");\nvar generators_1 = __webpack_require__(/*! ../generators */ \"(app-pages-browser)/../web-sdk/dist/generators.js\");\nvar requests_1 = __webpack_require__(/*! ../requests */ \"(app-pages-browser)/../web-sdk/dist/requests.js\");\nvar loginRedirect = function(common) {\n    return __awaiter(void 0, void 0, void 0, function() {\n        var state, _a, codeChallenge, codeVerifier, e_1;\n        return __generator(this, function(_b) {\n            switch(_b.label){\n                case 0:\n                    state = (0, generators_1.genAuthorizeState)(21);\n                    return [\n                        4 /*yield*/ ,\n                        (0, generators_1.genCodeVerifierAndChallenge)()\n                    ];\n                case 1:\n                    _a = _b.sent(), codeChallenge = _a.codeChallenge, codeVerifier = _a.codeVerifier;\n                    window.sessionStorage.setItem(definitions_1.SessionStorageKey.State, state);\n                    window.sessionStorage.setItem(definitions_1.SessionStorageKey.CodeVerifier, codeVerifier);\n                    _b.label = 2;\n                case 2:\n                    _b.trys.push([\n                        2,\n                        4,\n                        ,\n                        5\n                    ]);\n                    return [\n                        4 /*yield*/ ,\n                        (0, requests_1.getAuthorize)(common, {\n                            state: state,\n                            codeChallenge: codeChallenge\n                        })\n                    ];\n                case 3:\n                    _b.sent();\n                    return [\n                        2 /*return*/ ,\n                        true\n                    ];\n                case 4:\n                    e_1 = _b.sent();\n                    throw new Error(\"Failed to initial authorize flow: \".concat(e_1));\n                case 5:\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nexports.loginRedirect = loginRedirect;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi93ZWItc2RrL2Rpc3QvZmxvd3MvbG9naW5SZWRpcmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLElBQUlBLFlBQVksQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxTQUFTLElBQUssU0FBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNuRixTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBQ0EsSUFBSU8sY0FBYyxDQUFDLE1BQUcsS0FBSyxPQUFHLEVBQUVBLFdBQVcsSUFBSyxTQUFVbEIsT0FBTyxFQUFFbUIsSUFBSTtJQUNuRSxJQUFJQyxJQUFJO1FBQUVDLE9BQU87UUFBR0MsTUFBTTtZQUFh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QUU7b0JBQzVDLE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFLLElBQUdULGFBQWFVLDJCQUEyQjtxQkFBSTtnQkFDekUsS0FBSztvQkFDRE4sS0FBS0ksR0FBR2hDLElBQUksSUFBSTZCLGdCQUFnQkQsR0FBR0MsYUFBYSxFQUFFQyxlQUFlRixHQUFHRSxZQUFZO29CQUNoRkssT0FBT0MsY0FBYyxDQUFDQyxPQUFPLENBQUNmLGNBQWNnQixpQkFBaUIsQ0FBQ0MsS0FBSyxFQUFFWjtvQkFDckVRLE9BQU9DLGNBQWMsQ0FBQ0MsT0FBTyxDQUFDZixjQUFjZ0IsaUJBQWlCLENBQUNFLFlBQVksRUFBRVY7b0JBQzVFRSxHQUFHakMsS0FBSyxHQUFHO2dCQUNmLEtBQUs7b0JBQ0RpQyxHQUFHOUIsSUFBSSxDQUFDZSxJQUFJLENBQUM7d0JBQUM7d0JBQUc7O3dCQUFLO3FCQUFFO29CQUN4QixPQUFPO3dCQUFDLEVBQUUsT0FBTzt3QkFBSyxJQUFHUSxXQUFXZ0IsWUFBWSxFQUFFZixRQUFROzRCQUNsREMsT0FBT0E7NEJBQ1BFLGVBQWVBO3dCQUNuQjtxQkFBRztnQkFDWCxLQUFLO29CQUNERyxHQUFHaEMsSUFBSTtvQkFDUCxPQUFPO3dCQUFDLEVBQUUsUUFBUTt3QkFBSTtxQkFBSztnQkFDL0IsS0FBSztvQkFDRCtCLE1BQU1DLEdBQUdoQyxJQUFJO29CQUNiLE1BQU0sSUFBSTBDLE1BQU0scUNBQXFDQyxNQUFNLENBQUNaO2dCQUNoRSxLQUFLO29CQUFHLE9BQU87d0JBQUMsRUFBRSxRQUFRO3FCQUFHO1lBQ2pDO1FBQ0o7SUFDSjtBQUFJO0FBQ0pYLHFCQUFxQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vd2ViLXNkay9kaXN0L2Zsb3dzL2xvZ2luUmVkaXJlY3QuanM/M2E2ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubG9naW5SZWRpcmVjdCA9IHZvaWQgMDtcbnZhciBkZWZpbml0aW9uc18xID0gcmVxdWlyZShcIi4uL2RlZmluaXRpb25zXCIpO1xudmFyIGdlbmVyYXRvcnNfMSA9IHJlcXVpcmUoXCIuLi9nZW5lcmF0b3JzXCIpO1xudmFyIHJlcXVlc3RzXzEgPSByZXF1aXJlKFwiLi4vcmVxdWVzdHNcIik7XG52YXIgbG9naW5SZWRpcmVjdCA9IGZ1bmN0aW9uIChjb21tb24pIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlLCBfYSwgY29kZUNoYWxsZW5nZSwgY29kZVZlcmlmaWVyLCBlXzE7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xuICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgc3RhdGUgPSAoMCwgZ2VuZXJhdG9yc18xLmdlbkF1dGhvcml6ZVN0YXRlKSgyMSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgKDAsIGdlbmVyYXRvcnNfMS5nZW5Db2RlVmVyaWZpZXJBbmRDaGFsbGVuZ2UpKCldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9hID0gX2Iuc2VudCgpLCBjb2RlQ2hhbGxlbmdlID0gX2EuY29kZUNoYWxsZW5nZSwgY29kZVZlcmlmaWVyID0gX2EuY29kZVZlcmlmaWVyO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGRlZmluaXRpb25zXzEuU2Vzc2lvblN0b3JhZ2VLZXkuU3RhdGUsIHN0YXRlKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShkZWZpbml0aW9uc18xLlNlc3Npb25TdG9yYWdlS2V5LkNvZGVWZXJpZmllciwgY29kZVZlcmlmaWVyKTtcbiAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDI7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgX2IudHJ5cy5wdXNoKFsyLCA0LCAsIDVdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCAoMCwgcmVxdWVzdHNfMS5nZXRBdXRob3JpemUpKGNvbW1vbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUNoYWxsZW5nZTogY29kZUNoYWxsZW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgZV8xID0gX2Iuc2VudCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBpbml0aWFsIGF1dGhvcml6ZSBmbG93OiBcIi5jb25jYXQoZV8xKSk7XG4gICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLmxvZ2luUmVkaXJlY3QgPSBsb2dpblJlZGlyZWN0O1xuIl0sIm5hbWVzIjpbIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fZ2VuZXJhdG9yIiwiYm9keSIsIl8iLCJsYWJlbCIsInNlbnQiLCJ0IiwidHJ5cyIsIm9wcyIsImYiLCJ5IiwiZyIsInZlcmIiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm4iLCJ2Iiwib3AiLCJUeXBlRXJyb3IiLCJjYWxsIiwicG9wIiwibGVuZ3RoIiwicHVzaCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsImxvZ2luUmVkaXJlY3QiLCJkZWZpbml0aW9uc18xIiwicmVxdWlyZSIsImdlbmVyYXRvcnNfMSIsInJlcXVlc3RzXzEiLCJjb21tb24iLCJzdGF0ZSIsIl9hIiwiY29kZUNoYWxsZW5nZSIsImNvZGVWZXJpZmllciIsImVfMSIsIl9iIiwiZ2VuQXV0aG9yaXplU3RhdGUiLCJnZW5Db2RlVmVyaWZpZXJBbmRDaGFsbGVuZ2UiLCJ3aW5kb3ciLCJzZXNzaW9uU3RvcmFnZSIsInNldEl0ZW0iLCJTZXNzaW9uU3RvcmFnZUtleSIsIlN0YXRlIiwiQ29kZVZlcmlmaWVyIiwiZ2V0QXV0aG9yaXplIiwiRXJyb3IiLCJjb25jYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../web-sdk/dist/flows/loginRedirect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/../web-sdk/dist/requests.js":
/*!***********************************!*\
  !*** ../web-sdk/dist/requests.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.postTokenByRefreshToken = exports.postTokenByAuthCode = exports.postLogout = exports.getUserInfo = exports.getAuthorize = void 0;\nvar getAuthorize = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var combinedScopes, scopeQueries, url, res, data;\n        var baseUri = _c.baseUri, clientId = _c.clientId, _e = _c.scopes, scopes = _e === void 0 ? [] : _e, redirectUri = _c.redirectUri, setIsLoading = _c.setIsLoading;\n        var state = _d.state, codeChallenge = _d.codeChallenge;\n        return __generator(this, function(_f) {\n            switch(_f.label){\n                case 0:\n                    combinedScopes = __spreadArray(__spreadArray([], scopes, true), [\n                        \"openid\",\n                        \"profile\",\n                        \"offline_access\"\n                    ], false);\n                    scopeQueries = combinedScopes.reduce(function(scopeQueries, scope) {\n                        return \"\".concat(scopeQueries, \"&scope=\").concat(scope);\n                    }, \"\");\n                    url = baseUri + \"/oauth2/authorize?response_type=code&state=\" + state + \"&client_id=\" + clientId + \"&redirect_uri=\" + redirectUri + \"&code_challenge=\" + codeChallenge + \"&code_challenge_type=S256\" + scopeQueries;\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"GET\"\n                        })\n                    ];\n                case 1:\n                    res = _f.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _f.sent();\n                    if (!res.ok) {\n                        throw new Error(data);\n                    }\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nexports.getAuthorize = getAuthorize;\nvar getUserInfo = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var accessToken = _d.accessToken;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/userinfo\");\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"GET\",\n                            headers: {\n                                Authorization: \"Bearer \".concat(accessToken)\n                            }\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.getUserInfo = getUserInfo;\nvar postLogout = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, data, urlEncodedData;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var refreshToken = _d.refreshToken, postLogoutRedirectUri = _d.postLogoutRedirectUri;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/logout\");\n                    data = {\n                        refreshToken: refreshToken,\n                        postLogoutRedirectUri: postLogoutRedirectUri\n                    };\n                    urlEncodedData = new URLSearchParams(data).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nexports.postLogout = postLogout;\nvar postTokenByAuthCode = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, body, urlEncodedData, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading, redirectUri = _c.redirectUri;\n        var code = _d.code, codeVerifier = _d.codeVerifier;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/token\");\n                    body = {\n                        grant_type: \"authorization_code\",\n                        code: code,\n                        redirect_uri: redirectUri,\n                        code_verifier: codeVerifier\n                    };\n                    urlEncodedData = new URLSearchParams(body).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.postTokenByAuthCode = postTokenByAuthCode;\nvar postTokenByRefreshToken = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, body, urlEncodedData, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var refreshToken = _d.refreshToken;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/token\");\n                    body = {\n                        grant_type: \"refresh_token\",\n                        refreshToken: refreshToken\n                    };\n                    urlEncodedData = new URLSearchParams(body).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.postTokenByRefreshToken = postTokenByRefreshToken;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi93ZWItc2RrL2Rpc3QvcmVxdWVzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGNBQWMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFD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QztRQUNwQyxJQUFJQyxVQUFVUCxHQUFHTyxPQUFPLEVBQUVLLGVBQWVaLEdBQUdZLFlBQVk7UUFDeEQsSUFBSWUsZUFBZTFCLEdBQUcwQixZQUFZO1FBQ2xDLE9BQU92RSxZQUFZLElBQUksRUFBRSxTQUFVcUQsRUFBRTtZQUNqQyxPQUFRQSxHQUFHbEQsS0FBSztnQkFDWixLQUFLO29CQUNENkMsTUFBTSxHQUFHZixNQUFNLENBQUNrQixTQUFTO29CQUN6QmxELE9BQU87d0JBQ0g0RSxZQUFZO3dCQUNaTixjQUFjQTtvQkFDbEI7b0JBQ0FELGlCQUFpQixJQUFJRyxnQkFBZ0J4RSxNQUFNeUUsUUFBUTtvQkFDbkRsQixhQUFhO29CQUNiLE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFJTSxNQUFNZCxLQUFLOzRCQUN4QmUsUUFBUTs0QkFDUjlELE1BQU1xRTt3QkFDVjtxQkFBRztnQkFDWCxLQUFLO29CQUNEckIsTUFBTUksR0FBR2pELElBQUk7b0JBQ2IsT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUk2QyxJQUFJZSxJQUFJO3FCQUFHO2dCQUNwQyxLQUFLO29CQUNEZCxPQUFPRyxHQUFHakQsSUFBSTtvQkFDZG9ELGFBQWE7b0JBQ2IsT0FBTzt3QkFBQyxFQUFFLFFBQVE7d0JBQUlOO3FCQUFLO1lBQ25DO1FBQ0o7SUFDSjtBQUFJO0FBQ0pkLCtCQUErQixHQUFHQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi4vd2ViLXNkay9kaXN0L3JlcXVlc3RzLmpzPzE2YTAiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuID0gZXhwb3J0cy5wb3N0VG9rZW5CeUF1dGhDb2RlID0gZXhwb3J0cy5wb3N0TG9nb3V0ID0gZXhwb3J0cy5nZXRVc2VySW5mbyA9IGV4cG9ydHMuZ2V0QXV0aG9yaXplID0gdm9pZCAwO1xudmFyIGdldEF1dGhvcml6ZSA9IGZ1bmN0aW9uIChfYSwgX2IpIHsgcmV0dXJuIF9fYXdhaXRlcih2b2lkIDAsIFtfYSwgX2JdLCB2b2lkIDAsIGZ1bmN0aW9uIChfYywgX2QpIHtcbiAgICB2YXIgY29tYmluZWRTY29wZXMsIHNjb3BlUXVlcmllcywgdXJsLCByZXMsIGRhdGE7XG4gICAgdmFyIGJhc2VVcmkgPSBfYy5iYXNlVXJpLCBjbGllbnRJZCA9IF9jLmNsaWVudElkLCBfZSA9IF9jLnNjb3Blcywgc2NvcGVzID0gX2UgPT09IHZvaWQgMCA/IFtdIDogX2UsIHJlZGlyZWN0VXJpID0gX2MucmVkaXJlY3RVcmksIHNldElzTG9hZGluZyA9IF9jLnNldElzTG9hZGluZztcbiAgICB2YXIgc3RhdGUgPSBfZC5zdGF0ZSwgY29kZUNoYWxsZW5nZSA9IF9kLmNvZGVDaGFsbGVuZ2U7XG4gICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZikge1xuICAgICAgICBzd2l0Y2ggKF9mLmxhYmVsKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgY29tYmluZWRTY29wZXMgPSBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHNjb3BlcywgdHJ1ZSksIFsnb3BlbmlkJywgJ3Byb2ZpbGUnLCAnb2ZmbGluZV9hY2Nlc3MnXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHNjb3BlUXVlcmllcyA9IGNvbWJpbmVkU2NvcGVzLnJlZHVjZShmdW5jdGlvbiAoc2NvcGVRdWVyaWVzLCBzY29wZSkgeyByZXR1cm4gXCJcIi5jb25jYXQoc2NvcGVRdWVyaWVzLCBcIiZzY29wZT1cIikuY29uY2F0KHNjb3BlKTsgfSwgJycpO1xuICAgICAgICAgICAgICAgIHVybCA9IGJhc2VVcmkgK1xuICAgICAgICAgICAgICAgICAgICAnL29hdXRoMi9hdXRob3JpemU/cmVzcG9uc2VfdHlwZT1jb2RlJnN0YXRlPScgK1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSArXG4gICAgICAgICAgICAgICAgICAgICcmY2xpZW50X2lkPScgK1xuICAgICAgICAgICAgICAgICAgICBjbGllbnRJZCArXG4gICAgICAgICAgICAgICAgICAgICcmcmVkaXJlY3RfdXJpPScgK1xuICAgICAgICAgICAgICAgICAgICByZWRpcmVjdFVyaSArXG4gICAgICAgICAgICAgICAgICAgICcmY29kZV9jaGFsbGVuZ2U9JyArXG4gICAgICAgICAgICAgICAgICAgIGNvZGVDaGFsbGVuZ2UgK1xuICAgICAgICAgICAgICAgICAgICAnJmNvZGVfY2hhbGxlbmdlX3R5cGU9UzI1NicgK1xuICAgICAgICAgICAgICAgICAgICBzY29wZVF1ZXJpZXM7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwgeyBtZXRob2Q6ICdHRVQnIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLmpzb24oKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0QXV0aG9yaXplID0gZ2V0QXV0aG9yaXplO1xudmFyIGdldFVzZXJJbmZvID0gZnVuY3Rpb24gKF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW19hLCBfYl0sIHZvaWQgMCwgZnVuY3Rpb24gKF9jLCBfZCkge1xuICAgIHZhciB1cmwsIHJlcywgZGF0YTtcbiAgICB2YXIgYmFzZVVyaSA9IF9jLmJhc2VVcmksIHNldElzTG9hZGluZyA9IF9jLnNldElzTG9hZGluZztcbiAgICB2YXIgYWNjZXNzVG9rZW4gPSBfZC5hY2Nlc3NUb2tlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdXNlcmluZm9cIik7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KGFjY2Vzc1Rva2VuKSB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRVc2VySW5mbyA9IGdldFVzZXJJbmZvO1xudmFyIHBvc3RMb2dvdXQgPSBmdW5jdGlvbiAoX2EsIF9iKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbX2EsIF9iXSwgdm9pZCAwLCBmdW5jdGlvbiAoX2MsIF9kKSB7XG4gICAgdmFyIHVybCwgZGF0YSwgdXJsRW5jb2RlZERhdGE7XG4gICAgdmFyIGJhc2VVcmkgPSBfYy5iYXNlVXJpLCBzZXRJc0xvYWRpbmcgPSBfYy5zZXRJc0xvYWRpbmc7XG4gICAgdmFyIHJlZnJlc2hUb2tlbiA9IF9kLnJlZnJlc2hUb2tlbiwgcG9zdExvZ291dFJlZGlyZWN0VXJpID0gX2QucG9zdExvZ291dFJlZGlyZWN0VXJpO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmksIFwiL29hdXRoMi9sb2dvdXRcIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHBvc3RMb2dvdXRSZWRpcmVjdFVyaTogcG9zdExvZ291dFJlZGlyZWN0VXJpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdXJsRW5jb2RlZERhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB1cmxFbmNvZGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RMb2dvdXQgPSBwb3N0TG9nb3V0O1xudmFyIHBvc3RUb2tlbkJ5QXV0aENvZGUgPSBmdW5jdGlvbiAoX2EsIF9iKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbX2EsIF9iXSwgdm9pZCAwLCBmdW5jdGlvbiAoX2MsIF9kKSB7XG4gICAgdmFyIHVybCwgYm9keSwgdXJsRW5jb2RlZERhdGEsIHJlcywgZGF0YTtcbiAgICB2YXIgYmFzZVVyaSA9IF9jLmJhc2VVcmksIHNldElzTG9hZGluZyA9IF9jLnNldElzTG9hZGluZywgcmVkaXJlY3RVcmkgPSBfYy5yZWRpcmVjdFVyaTtcbiAgICB2YXIgY29kZSA9IF9kLmNvZGUsIGNvZGVWZXJpZmllciA9IF9kLmNvZGVWZXJpZmllcjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHVybEVuY29kZWREYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhib2R5KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogdXJsRW5jb2RlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLmpzb24oKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RUb2tlbkJ5QXV0aENvZGUgPSBwb3N0VG9rZW5CeUF1dGhDb2RlO1xudmFyIHBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuID0gZnVuY3Rpb24gKF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW19hLCBfYl0sIHZvaWQgMCwgZnVuY3Rpb24gKF9jLCBfZCkge1xuICAgIHZhciB1cmwsIGJvZHksIHVybEVuY29kZWREYXRhLCByZXMsIGRhdGE7XG4gICAgdmFyIGJhc2VVcmkgPSBfYy5iYXNlVXJpLCBzZXRJc0xvYWRpbmcgPSBfYy5zZXRJc0xvYWRpbmc7XG4gICAgdmFyIHJlZnJlc2hUb2tlbiA9IF9kLnJlZnJlc2hUb2tlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHVybEVuY29kZWREYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhib2R5KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogdXJsRW5jb2RlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLmpzb24oKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuID0gcG9zdFRva2VuQnlSZWZyZXNoVG9rZW47XG4iXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJvcCIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJhcmd1bWVudHMiLCJpIiwibCIsImFyIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNvbmNhdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuIiwicG9zdFRva2VuQnlBdXRoQ29kZSIsInBvc3RMb2dvdXQiLCJnZXRVc2VySW5mbyIsImdldEF1dGhvcml6ZSIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiY29tYmluZWRTY29wZXMiLCJzY29wZVF1ZXJpZXMiLCJ1cmwiLCJyZXMiLCJkYXRhIiwiYmFzZVVyaSIsImNsaWVudElkIiwiX2UiLCJzY29wZXMiLCJyZWRpcmVjdFVyaSIsInNldElzTG9hZGluZyIsInN0YXRlIiwiY29kZUNoYWxsZW5nZSIsIl9mIiwicmVkdWNlIiwic2NvcGUiLCJmZXRjaCIsIm1ldGhvZCIsImpzb24iLCJvayIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsInVybEVuY29kZWREYXRhIiwicmVmcmVzaFRva2VuIiwicG9zdExvZ291dFJlZGlyZWN0VXJpIiwiVVJMU2VhcmNoUGFyYW1zIiwidG9TdHJpbmciLCJjb2RlIiwiY29kZVZlcmlmaWVyIiwiZ3JhbnRfdHlwZSIsInJlZGlyZWN0X3VyaSIsImNvZGVfdmVyaWZpZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/../web-sdk/dist/requests.js\n"));

/***/ })

});