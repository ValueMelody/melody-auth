"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/../web-sdk/dist/requests.js":
/*!***********************************!*\
  !*** ../web-sdk/dist/requests.js ***!
  \***********************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("\nvar __awaiter = (void 0) && (void 0).__awaiter || function(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (void 0) && (void 0).__generator || function(thisArg, body) {\n    var _ = {\n        label: 0,\n        sent: function() {\n            if (t[0] & 1) throw t[1];\n            return t[1];\n        },\n        trys: [],\n        ops: []\n    }, f, y, t, g;\n    return g = {\n        next: verb(0),\n        \"throw\": verb(1),\n        \"return\": verb(2)\n    }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() {\n        return this;\n    }), g;\n    function verb(n) {\n        return function(v) {\n            return step([\n                n,\n                v\n            ]);\n        };\n    }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while(g && (g = 0, op[0] && (_ = 0)), _)try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [\n                op[0] & 2,\n                t.value\n            ];\n            switch(op[0]){\n                case 0:\n                case 1:\n                    t = op;\n                    break;\n                case 4:\n                    _.label++;\n                    return {\n                        value: op[1],\n                        done: false\n                    };\n                case 5:\n                    _.label++;\n                    y = op[1];\n                    op = [\n                        0\n                    ];\n                    continue;\n                case 7:\n                    op = _.ops.pop();\n                    _.trys.pop();\n                    continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n                        _ = 0;\n                        continue;\n                    }\n                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n                        _.label = op[1];\n                        break;\n                    }\n                    if (op[0] === 6 && _.label < t[1]) {\n                        _.label = t[1];\n                        t = op;\n                        break;\n                    }\n                    if (t && _.label < t[2]) {\n                        _.label = t[2];\n                        _.ops.push(op);\n                        break;\n                    }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop();\n                    continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) {\n            op = [\n                6,\n                e\n            ];\n            y = 0;\n        } finally{\n            f = t = 0;\n        }\n        if (op[0] & 5) throw op[1];\n        return {\n            value: op[0] ? op[1] : void 0,\n            done: true\n        };\n    }\n};\nvar __spreadArray = (void 0) && (void 0).__spreadArray || function(to, from, pack) {\n    if (pack || arguments.length === 2) for(var i = 0, l = from.length, ar; i < l; i++){\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.postTokenByRefreshToken = exports.postTokenByAuthCode = exports.postLogout = exports.getUserInfo = exports.getAuthorize = void 0;\nvar getAuthorize = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var combinedScopes, scopeQueries, url, res, data;\n        var baseUri = _c.baseUri, clientId = _c.clientId, _e = _c.scopes, scopes = _e === void 0 ? [] : _e, redirectUri = _c.redirectUri, setIsLoading = _c.setIsLoading;\n        var state = _d.state, codeChallenge = _d.codeChallenge;\n        return __generator(this, function(_f) {\n            switch(_f.label){\n                case 0:\n                    combinedScopes = __spreadArray(__spreadArray([], scopes, true), [\n                        \"openid\",\n                        \"profile\",\n                        \"offline_access\"\n                    ], false);\n                    scopeQueries = combinedScopes.reduce(function(scopeQueries, scope) {\n                        return \"\".concat(scopeQueries, \"&scope=\").concat(scope);\n                    }, \"\");\n                    url = baseUri + \"/oauth2/authorize?response_type=code&state=\" + state + \"&client_id=\" + clientId + \"&redirect_uri=\" + redirectUri + \"&code_challenge=\" + codeChallenge + \"&code_challenge_metho=S256\" + scopeQueries;\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"GET\"\n                        })\n                    ];\n                case 1:\n                    res = _f.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.text()\n                    ];\n                case 2:\n                    data = _f.sent();\n                    if (!res.ok) {\n                        throw new Error(data);\n                    }\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nexports.getAuthorize = getAuthorize;\nvar getUserInfo = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var accessToken = _d.accessToken;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/userinfo\");\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"GET\",\n                            headers: {\n                                Authorization: \"Bearer \".concat(accessToken)\n                            }\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.getUserInfo = getUserInfo;\nvar postLogout = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, data, urlEncodedData;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var refreshToken = _d.refreshToken, postLogoutRedirectUri = _d.postLogoutRedirectUri;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/logout\");\n                    data = {\n                        refreshToken: refreshToken,\n                        postLogoutRedirectUri: postLogoutRedirectUri\n                    };\n                    urlEncodedData = new URLSearchParams(data).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ \n                    ];\n            }\n        });\n    });\n};\nexports.postLogout = postLogout;\nvar postTokenByAuthCode = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, body, urlEncodedData, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading, redirectUri = _c.redirectUri;\n        var code = _d.code, codeVerifier = _d.codeVerifier;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/token\");\n                    body = {\n                        grant_type: \"authorization_code\",\n                        code: code,\n                        redirect_uri: redirectUri,\n                        code_verifier: codeVerifier\n                    };\n                    urlEncodedData = new URLSearchParams(body).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.postTokenByAuthCode = postTokenByAuthCode;\nvar postTokenByRefreshToken = function(_a, _b) {\n    return __awaiter(void 0, [\n        _a,\n        _b\n    ], void 0, function(_c, _d) {\n        var url, body, urlEncodedData, res, data;\n        var baseUri = _c.baseUri, setIsLoading = _c.setIsLoading;\n        var refreshToken = _d.refreshToken;\n        return __generator(this, function(_e) {\n            switch(_e.label){\n                case 0:\n                    url = \"\".concat(baseUri, \"/oauth2/token\");\n                    body = {\n                        grant_type: \"refresh_token\",\n                        refreshToken: refreshToken\n                    };\n                    urlEncodedData = new URLSearchParams(body).toString();\n                    setIsLoading(true);\n                    return [\n                        4 /*yield*/ ,\n                        fetch(url, {\n                            method: \"POST\",\n                            body: urlEncodedData\n                        })\n                    ];\n                case 1:\n                    res = _e.sent();\n                    return [\n                        4 /*yield*/ ,\n                        res.json()\n                    ];\n                case 2:\n                    data = _e.sent();\n                    setIsLoading(false);\n                    return [\n                        2 /*return*/ ,\n                        data\n                    ];\n            }\n        });\n    });\n};\nexports.postTokenByRefreshToken = postTokenByRefreshToken;\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uLi93ZWItc2RrL2Rpc3QvcmVxdWVzdHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYixJQUFJQSxZQUFZLENBQUMsTUFBRyxLQUFLLE9BQUcsRUFBRUEsU0FBUyxJQUFLLFNBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDbkYsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUNBLElBQUlPLGNBQWMsQ0FBQyxNQUFHLEtBQUssT0FBRyxFQUFFQSxXQUFXLElBQUssU0FBVWxCLE9BQU8sRUFBRW1CLElBQUk7SUFDbkUsSUFBSUMsSUFBSTtRQUFFQyxPQUFPO1FBQUdDLE1BQU07WUFBYSxJQUFJQyxDQUFD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LEtBQUtDO1FBQ3BDLElBQUlDLFVBQVVQLEdBQUdPLE9BQU8sRUFBRUssZUFBZVosR0FBR1ksWUFBWTtRQUN4RCxJQUFJZ0IsZUFBZTNCLEdBQUcyQixZQUFZO1FBQ2xDLE9BQU94RSxZQUFZLElBQUksRUFBRSxTQUFVcUQsRUFBRTtZQUNqQyxPQUFRQSxHQUFHbEQsS0FBSztnQkFDWixLQUFLO29CQUNENkMsTUFBTSxHQUFHZixNQUFNLENBQUNrQixTQUFTO29CQUN6QmxELE9BQU87d0JBQ0g2RSxZQUFZO3dCQUNaTixjQUFjQTtvQkFDbEI7b0JBQ0FELGlCQUFpQixJQUFJRyxnQkFBZ0J6RSxNQUFNMEUsUUFBUTtvQkFDbkRuQixhQUFhO29CQUNiLE9BQU87d0JBQUMsRUFBRSxPQUFPO3dCQUFJTSxNQUFNZCxLQUFLOzRCQUN4QmUsUUFBUTs0QkFDUjlELE1BQU1zRTt3QkFDVjtxQkFBRztnQkFDWCxLQUFLO29CQUNEdEIsTUFBTUksR0FBR2pELElBQUk7b0JBQ2IsT0FBTzt3QkFBQyxFQUFFLE9BQU87d0JBQUk2QyxJQUFJcUIsSUFBSTtxQkFBRztnQkFDcEMsS0FBSztvQkFDRHBCLE9BQU9HLEdBQUdqRCxJQUFJO29CQUNkb0QsYUFBYTtvQkFDYixPQUFPO3dCQUFDLEVBQUUsUUFBUTt3QkFBSU47cUJBQUs7WUFDbkM7UUFDSjtJQUNKO0FBQUk7QUFDSmQsK0JBQStCLEdBQUdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi93ZWItc2RrL2Rpc3QvcmVxdWVzdHMuanM/MTZhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucG9zdFRva2VuQnlSZWZyZXNoVG9rZW4gPSBleHBvcnRzLnBvc3RUb2tlbkJ5QXV0aENvZGUgPSBleHBvcnRzLnBvc3RMb2dvdXQgPSBleHBvcnRzLmdldFVzZXJJbmZvID0gZXhwb3J0cy5nZXRBdXRob3JpemUgPSB2b2lkIDA7XG52YXIgZ2V0QXV0aG9yaXplID0gZnVuY3Rpb24gKF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW19hLCBfYl0sIHZvaWQgMCwgZnVuY3Rpb24gKF9jLCBfZCkge1xuICAgIHZhciBjb21iaW5lZFNjb3Blcywgc2NvcGVRdWVyaWVzLCB1cmwsIHJlcywgZGF0YTtcbiAgICB2YXIgYmFzZVVyaSA9IF9jLmJhc2VVcmksIGNsaWVudElkID0gX2MuY2xpZW50SWQsIF9lID0gX2Muc2NvcGVzLCBzY29wZXMgPSBfZSA9PT0gdm9pZCAwID8gW10gOiBfZSwgcmVkaXJlY3RVcmkgPSBfYy5yZWRpcmVjdFVyaSwgc2V0SXNMb2FkaW5nID0gX2Muc2V0SXNMb2FkaW5nO1xuICAgIHZhciBzdGF0ZSA9IF9kLnN0YXRlLCBjb2RlQ2hhbGxlbmdlID0gX2QuY29kZUNoYWxsZW5nZTtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9mKSB7XG4gICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBjb21iaW5lZFNjb3BlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgc2NvcGVzLCB0cnVlKSwgWydvcGVuaWQnLCAncHJvZmlsZScsICdvZmZsaW5lX2FjY2VzcyddLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgc2NvcGVRdWVyaWVzID0gY29tYmluZWRTY29wZXMucmVkdWNlKGZ1bmN0aW9uIChzY29wZVF1ZXJpZXMsIHNjb3BlKSB7IHJldHVybiBcIlwiLmNvbmNhdChzY29wZVF1ZXJpZXMsIFwiJnNjb3BlPVwiKS5jb25jYXQoc2NvcGUpOyB9LCAnJyk7XG4gICAgICAgICAgICAgICAgdXJsID0gYmFzZVVyaSArXG4gICAgICAgICAgICAgICAgICAgICcvb2F1dGgyL2F1dGhvcml6ZT9yZXNwb25zZV90eXBlPWNvZGUmc3RhdGU9JyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlICtcbiAgICAgICAgICAgICAgICAgICAgJyZjbGllbnRfaWQ9JyArXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkICtcbiAgICAgICAgICAgICAgICAgICAgJyZyZWRpcmVjdF91cmk9JyArXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0VXJpICtcbiAgICAgICAgICAgICAgICAgICAgJyZjb2RlX2NoYWxsZW5nZT0nICtcbiAgICAgICAgICAgICAgICAgICAgY29kZUNoYWxsZW5nZSArXG4gICAgICAgICAgICAgICAgICAgICcmY29kZV9jaGFsbGVuZ2VfbWV0aG89UzI1NicgK1xuICAgICAgICAgICAgICAgICAgICBzY29wZVF1ZXJpZXM7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwgeyBtZXRob2Q6ICdHRVQnIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZi5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLnRleHQoKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9mLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi9dO1xuICAgICAgICB9XG4gICAgfSk7XG59KTsgfTtcbmV4cG9ydHMuZ2V0QXV0aG9yaXplID0gZ2V0QXV0aG9yaXplO1xudmFyIGdldFVzZXJJbmZvID0gZnVuY3Rpb24gKF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW19hLCBfYl0sIHZvaWQgMCwgZnVuY3Rpb24gKF9jLCBfZCkge1xuICAgIHZhciB1cmwsIHJlcywgZGF0YTtcbiAgICB2YXIgYmFzZVVyaSA9IF9jLmJhc2VVcmksIHNldElzTG9hZGluZyA9IF9jLnNldElzTG9hZGluZztcbiAgICB2YXIgYWNjZXNzVG9rZW4gPSBfZC5hY2Nlc3NUb2tlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdXNlcmluZm9cIik7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogXCJCZWFyZXIgXCIuY29uY2F0KGFjY2Vzc1Rva2VuKSB9LFxuICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgcmVzID0gX2Uuc2VudCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlcy5qc29uKCldO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgIGRhdGEgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZGF0YV07XG4gICAgICAgIH1cbiAgICB9KTtcbn0pOyB9O1xuZXhwb3J0cy5nZXRVc2VySW5mbyA9IGdldFVzZXJJbmZvO1xudmFyIHBvc3RMb2dvdXQgPSBmdW5jdGlvbiAoX2EsIF9iKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbX2EsIF9iXSwgdm9pZCAwLCBmdW5jdGlvbiAoX2MsIF9kKSB7XG4gICAgdmFyIHVybCwgZGF0YSwgdXJsRW5jb2RlZERhdGE7XG4gICAgdmFyIGJhc2VVcmkgPSBfYy5iYXNlVXJpLCBzZXRJc0xvYWRpbmcgPSBfYy5zZXRJc0xvYWRpbmc7XG4gICAgdmFyIHJlZnJlc2hUb2tlbiA9IF9kLnJlZnJlc2hUb2tlbiwgcG9zdExvZ291dFJlZGlyZWN0VXJpID0gX2QucG9zdExvZ291dFJlZGlyZWN0VXJpO1xuICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcbiAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHVybCA9IFwiXCIuY29uY2F0KGJhc2VVcmksIFwiL29hdXRoMi9sb2dvdXRcIik7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZWZyZXNoVG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHBvc3RMb2dvdXRSZWRpcmVjdFVyaTogcG9zdExvZ291dFJlZGlyZWN0VXJpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdXJsRW5jb2RlZERhdGEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGRhdGEpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGZldGNoKHVybCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiB1cmxFbmNvZGVkRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RMb2dvdXQgPSBwb3N0TG9nb3V0O1xudmFyIHBvc3RUb2tlbkJ5QXV0aENvZGUgPSBmdW5jdGlvbiAoX2EsIF9iKSB7IHJldHVybiBfX2F3YWl0ZXIodm9pZCAwLCBbX2EsIF9iXSwgdm9pZCAwLCBmdW5jdGlvbiAoX2MsIF9kKSB7XG4gICAgdmFyIHVybCwgYm9keSwgdXJsRW5jb2RlZERhdGEsIHJlcywgZGF0YTtcbiAgICB2YXIgYmFzZVVyaSA9IF9jLmJhc2VVcmksIHNldElzTG9hZGluZyA9IF9jLnNldElzTG9hZGluZywgcmVkaXJlY3RVcmkgPSBfYy5yZWRpcmVjdFVyaTtcbiAgICB2YXIgY29kZSA9IF9kLmNvZGUsIGNvZGVWZXJpZmllciA9IF9kLmNvZGVWZXJpZmllcjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ2F1dGhvcml6YXRpb25fY29kZScsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIHJlZGlyZWN0X3VyaTogcmVkaXJlY3RVcmksXG4gICAgICAgICAgICAgICAgICAgIGNvZGVfdmVyaWZpZXI6IGNvZGVWZXJpZmllcixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHVybEVuY29kZWREYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhib2R5KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogdXJsRW5jb2RlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLmpzb24oKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RUb2tlbkJ5QXV0aENvZGUgPSBwb3N0VG9rZW5CeUF1dGhDb2RlO1xudmFyIHBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuID0gZnVuY3Rpb24gKF9hLCBfYikgeyByZXR1cm4gX19hd2FpdGVyKHZvaWQgMCwgW19hLCBfYl0sIHZvaWQgMCwgZnVuY3Rpb24gKF9jLCBfZCkge1xuICAgIHZhciB1cmwsIGJvZHksIHVybEVuY29kZWREYXRhLCByZXMsIGRhdGE7XG4gICAgdmFyIGJhc2VVcmkgPSBfYy5iYXNlVXJpLCBzZXRJc0xvYWRpbmcgPSBfYy5zZXRJc0xvYWRpbmc7XG4gICAgdmFyIHJlZnJlc2hUb2tlbiA9IF9kLnJlZnJlc2hUb2tlbjtcbiAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9lKSB7XG4gICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB1cmwgPSBcIlwiLmNvbmNhdChiYXNlVXJpLCBcIi9vYXV0aDIvdG9rZW5cIik7XG4gICAgICAgICAgICAgICAgYm9keSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhbnRfdHlwZTogJ3JlZnJlc2hfdG9rZW4nLFxuICAgICAgICAgICAgICAgICAgICByZWZyZXNoVG9rZW46IHJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHVybEVuY29kZWREYXRhID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhib2R5KS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogdXJsRW5jb2RlZERhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICByZXMgPSBfZS5zZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgcmVzLmpzb24oKV07XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgZGF0YSA9IF9lLnNlbnQoKTtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBkYXRhXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7IH07XG5leHBvcnRzLnBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuID0gcG9zdFRva2VuQnlSZWZyZXNoVG9rZW47XG4iXSwibmFtZXMiOlsiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiX19nZW5lcmF0b3IiLCJib2R5IiwiXyIsImxhYmVsIiwic2VudCIsInQiLCJ0cnlzIiwib3BzIiwiZiIsInkiLCJnIiwidmVyYiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwibiIsInYiLCJvcCIsIlR5cGVFcnJvciIsImNhbGwiLCJwb3AiLCJsZW5ndGgiLCJwdXNoIiwiX19zcHJlYWRBcnJheSIsInRvIiwiZnJvbSIsInBhY2siLCJhcmd1bWVudHMiLCJpIiwibCIsImFyIiwiQXJyYXkiLCJwcm90b3R5cGUiLCJzbGljZSIsImNvbmNhdCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInBvc3RUb2tlbkJ5UmVmcmVzaFRva2VuIiwicG9zdFRva2VuQnlBdXRoQ29kZSIsInBvc3RMb2dvdXQiLCJnZXRVc2VySW5mbyIsImdldEF1dGhvcml6ZSIsIl9hIiwiX2IiLCJfYyIsIl9kIiwiY29tYmluZWRTY29wZXMiLCJzY29wZVF1ZXJpZXMiLCJ1cmwiLCJyZXMiLCJkYXRhIiwiYmFzZVVyaSIsImNsaWVudElkIiwiX2UiLCJzY29wZXMiLCJyZWRpcmVjdFVyaSIsInNldElzTG9hZGluZyIsInN0YXRlIiwiY29kZUNoYWxsZW5nZSIsIl9mIiwicmVkdWNlIiwic2NvcGUiLCJmZXRjaCIsIm1ldGhvZCIsInRleHQiLCJvayIsIkVycm9yIiwiYWNjZXNzVG9rZW4iLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImpzb24iLCJ1cmxFbmNvZGVkRGF0YSIsInJlZnJlc2hUb2tlbiIsInBvc3RMb2dvdXRSZWRpcmVjdFVyaSIsIlVSTFNlYXJjaFBhcmFtcyIsInRvU3RyaW5nIiwiY29kZSIsImNvZGVWZXJpZmllciIsImdyYW50X3R5cGUiLCJyZWRpcmVjdF91cmkiLCJjb2RlX3ZlcmlmaWVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/../web-sdk/dist/requests.js\n"));

/***/ })

});